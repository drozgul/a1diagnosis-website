<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Helix Visualization - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a1520;
            font-family: Arial, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00d4ff;
            font-size: 14px;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
            background: rgba(10, 21, 32, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00d4ff;
            font-size: 12px;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
            background: rgba(10, 21, 32, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            text-align: center;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00d4ff;
            font-size: 24px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="loading" class="pulse">Loading Enhanced DNA Helix...</div>
        <div id="info">
            <strong>Enhanced DNA Double Helix</strong><br>
            üñ±Ô∏è Drag to rotate ‚Ä¢ üîç Scroll to zoom<br>
            <span id="mode-indicator">‚è∏Ô∏è Auto-Orbit: OFF</span>
        </div>
        <div id="controls">
            Press <strong>SPACEBAR</strong> to toggle auto-orbit
        </div>
    </div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        let scene, camera, renderer, dnaGroup, composer;
        let particles = [];
        let stars = [];
        let mouse = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let autoOrbit = false;
        let time = 0;
        let dnaGlowSpheres = [];

        // Enhanced parameters
        const params = {
            bloomStrength: 0.7,
            bloomRadius: 0.35,
            bloomThreshold: 0.45,
            particleCount: 1000,
            autoOrbitSpeed: 0.0003
        };

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a1520, 0.02);

            // Create camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 18;

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0a1520, 1);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create DNA group
            dnaGroup = new THREE.Group();
            scene.add(dnaGroup);

            // Create star field background
            createStarField();

            // Create enhanced DNA helix
            createEnhancedDNAHelix();

            // Add enhanced lighting
            const ambientLight = new THREE.AmbientLight(0x1a4a5a, 0.3);
            scene.add(ambientLight);

            // Multiple point lights for better illumination
            const pointLight1 = new THREE.PointLight(0x00d4ff, 3, 100);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00d4ff, 3, 100);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0x66e7ff, 2, 100);
            pointLight3.position.set(0, 15, 0);
            scene.add(pointLight3);

            const pointLight4 = new THREE.PointLight(0x66e7ff, 2, 100);
            pointLight4.position.set(0, -15, 0);
            scene.add(pointLight4);

            // Setup post-processing with bloom
            setupPostProcessing();

            // Controls
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('wheel', onMouseWheel, false);
            document.addEventListener('keydown', onKeyDown, false);

            // Touch controls
            let touchStartX = 0;
            let touchStartY = 0;
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            document.addEventListener('touchmove', (e) => {
                if (autoOrbit) return;
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                targetRotation.y += deltaX * 0.005;
                targetRotation.x += deltaY * 0.005;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            // Window resize
            window.addEventListener('resize', onWindowResize, false);

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            // Start animation
            animate();
        }

        function setupPostProcessing() {
            // Create composer
            composer = new THREE.EffectComposer(renderer);

            // Render pass
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Bloom pass for intense glow
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                params.bloomStrength,
                params.bloomRadius,
                params.bloomThreshold
            );
            composer.addPass(bloomPass);
        }

        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];

            for (let i = 0; i < 3000; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0x00d4ff,
                size: 0.1,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });

            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
            stars.push(starField);
        }

        function createEnhancedDNAHelix() {
            const height = 20;
            const radius = 3;
            const segments = 200;
            const turnCount = 4;

            // Enhanced materials with stronger emissive properties
            const strandMaterial = new THREE.MeshPhongMaterial({
                color: 0x00d4ff,
                emissive: 0x00d4ff,
                emissiveIntensity: 0.5,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });

            const basePairMaterial = new THREE.MeshPhongMaterial({
                color: 0x00a8cc,
                emissive: 0x00a8cc,
                emissiveIntensity: 0.8,
                shininess: 50,
                transparent: true,
                opacity: 0.7
            });

            // Create helix strands
            for (let i = 0; i < segments; i++) {
                const t = (i / segments) * Math.PI * 2 * turnCount;
                const y = (i / segments) * height - height / 2;

                // Color gradients based on height
                const colorMix = (i / segments);

                // Strand 1: Cyan to Light Blue gradient
                const color1 = new THREE.Color().setHSL(0.52 + colorMix * 0.05, 1, 0.5);

                // Strand 2: White to Silver gradient
                const color2 = new THREE.Color().lerpColors(
                    new THREE.Color(0xffffff), // White
                    new THREE.Color(0xc0c0c0), // Silver
                    colorMix
                );

                // Strand 1
                const x1 = Math.cos(t) * radius;
                const z1 = Math.sin(t) * radius;

                // Strand 2 (180 degrees offset)
                const x2 = Math.cos(t + Math.PI) * radius;
                const z2 = Math.sin(t + Math.PI) * radius;

                // Create core spheres for strand 1
                const sphere1 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 16, 16),
                    strandMaterial.clone()
                );
                sphere1.material.color = color1;
                sphere1.material.emissive = color1;
                sphere1.position.set(x1, y, z1);
                sphere1.userData.baseEmissive = 0.5;
                sphere1.userData.phaseOffset = i * 0.1;
                dnaGroup.add(sphere1);
                dnaGlowSpheres.push(sphere1);

                // Multiple glow layers for depth - Layer 1 (inner)
                const glow1_inner = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: color1,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    })
                );
                glow1_inner.position.set(x1, y, z1);
                dnaGroup.add(glow1_inner);

                // Layer 2 (middle)
                const glow1_middle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: color1,
                        transparent: true,
                        opacity: 0.18,
                        blending: THREE.AdditiveBlending
                    })
                );
                glow1_middle.position.set(x1, y, z1);
                dnaGroup.add(glow1_middle);

                // Layer 3 (outer)
                const glow1_outer = new THREE.Mesh(
                    new THREE.SphereGeometry(0.45, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: color1,
                        transparent: true,
                        opacity: 0.06,
                        blending: THREE.AdditiveBlending
                    })
                );
                glow1_outer.position.set(x1, y, z1);
                dnaGroup.add(glow1_outer);

                // Create core spheres for strand 2
                const sphere2 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 16, 16),
                    strandMaterial.clone()
                );
                sphere2.material.color = color2;
                sphere2.material.emissive = color2;
                sphere2.position.set(x2, y, z2);
                sphere2.userData.baseEmissive = 0.5;
                sphere2.userData.phaseOffset = i * 0.1;
                dnaGroup.add(sphere2);
                dnaGlowSpheres.push(sphere2);

                // Multiple glow layers for strand 2
                const glow2_inner = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: color2,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    })
                );
                glow2_inner.position.set(x2, y, z2);
                dnaGroup.add(glow2_inner);

                const glow2_middle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: color2,
                        transparent: true,
                        opacity: 0.18,
                        blending: THREE.AdditiveBlending
                    })
                );
                glow2_middle.position.set(x2, y, z2);
                dnaGroup.add(glow2_middle);

                const glow2_outer = new THREE.Mesh(
                    new THREE.SphereGeometry(0.45, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: color2,
                        transparent: true,
                        opacity: 0.06,
                        blending: THREE.AdditiveBlending
                    })
                );
                glow2_outer.position.set(x2, y, z2);
                dnaGroup.add(glow2_outer);

                // Add connecting tubes
                if (i > 0) {
                    const prevT = ((i - 1) / segments) * Math.PI * 2 * turnCount;
                    const prevY = ((i - 1) / segments) * height - height / 2;

                    // Connection for strand 1
                    const prevX1 = Math.cos(prevT) * radius;
                    const prevZ1 = Math.sin(prevT) * radius;
                    const curve1 = new THREE.LineCurve3(
                        new THREE.Vector3(prevX1, prevY, prevZ1),
                        new THREE.Vector3(x1, y, z1)
                    );
                    const tubeGeometry1 = new THREE.TubeGeometry(curve1, 1, 0.1, 8, false);
                    const tube1 = new THREE.Mesh(tubeGeometry1, strandMaterial.clone());
                    tube1.material.color = color1;
                    tube1.material.emissive = color1;
                    dnaGroup.add(tube1);

                    // Connection for strand 2
                    const prevX2 = Math.cos(prevT + Math.PI) * radius;
                    const prevZ2 = Math.sin(prevT + Math.PI) * radius;
                    const curve2 = new THREE.LineCurve3(
                        new THREE.Vector3(prevX2, prevY, prevZ2),
                        new THREE.Vector3(x2, y, z2)
                    );
                    const tubeGeometry2 = new THREE.TubeGeometry(curve2, 1, 0.1, 8, false);
                    const tube2 = new THREE.Mesh(tubeGeometry2, strandMaterial.clone());
                    tube2.material.color = color2;
                    tube2.material.emissive = color2;
                    dnaGroup.add(tube2);
                }

                // Add base pairs (every 8 segments for more density)
                if (i % 8 === 0) {
                    const basePairCurve = new THREE.LineCurve3(
                        new THREE.Vector3(x1, y, z1),
                        new THREE.Vector3(x2, y, z2)
                    );
                    const basePairGeometry = new THREE.TubeGeometry(basePairCurve, 1, 0.06, 8, false);
                    const basePair = new THREE.Mesh(basePairGeometry, basePairMaterial);
                    dnaGroup.add(basePair);
                }

                // Add enhanced particles (5x more particles with varying sizes)
                if (i % 2 === 0) {
                    createEnhancedParticles(x1, y, z1, color1);
                    createEnhancedParticles(x2, y, z2, color2);
                }
            }

            // Add extra atmospheric particles (mix of both color schemes)
            for (let i = 0; i < params.particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radiusOffset = radius + (Math.random() - 0.5) * 6;
                const x = Math.cos(angle) * radiusOffset;
                const z = Math.sin(angle) * radiusOffset;
                const y = (Math.random() - 0.5) * height;

                const colorMix = Math.random();

                // Randomly choose between cyan gradient or white/silver gradient for variety
                let color;
                if (Math.random() > 0.5) {
                    // Cyan to light blue
                    color = new THREE.Color().setHSL(0.52 + colorMix * 0.05, 1, 0.5);
                } else {
                    // White to silver
                    color = new THREE.Color().lerpColors(
                        new THREE.Color(0xffffff),
                        new THREE.Color(0xc0c0c0),
                        colorMix
                    );
                }

                createEnhancedParticles(x, y, z, color);
            }
        }

        function createEnhancedParticles(x, y, z, color) {
            const sizes = [0.03, 0.05, 0.08, 0.12];
            const size = sizes[Math.floor(Math.random() * sizes.length)];

            const particleGeometry = new THREE.SphereGeometry(size, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);

            // Random offset
            particle.position.set(
                x + (Math.random() - 0.5) * 3,
                y + (Math.random() - 0.5) * 3,
                z + (Math.random() - 0.5) * 3
            );

            particle.userData = {
                velocity: {
                    x: (Math.random() - 0.5) * 0.015,
                    y: (Math.random() - 0.5) * 0.015,
                    z: (Math.random() - 0.5) * 0.015
                },
                originalOpacity: 0.3,
                baseSize: size,
                phaseOffset: Math.random() * Math.PI * 2
            };

            particles.push(particle);
            dnaGroup.add(particle);
        }

        function onMouseMove(event) {
            if (autoOrbit) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            targetRotation.y = mouse.x * Math.PI;
            targetRotation.x = mouse.y * Math.PI * 0.5;
        }

        function onMouseWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(5, Math.min(30, camera.position.z));
        }

        function onKeyDown(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                autoOrbit = !autoOrbit;
                const indicator = document.getElementById('mode-indicator');
                indicator.textContent = autoOrbit ? '‚ñ∂Ô∏è Auto-Orbit: ON' : '‚è∏Ô∏è Auto-Orbit: OFF';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Auto-orbit mode
            if (autoOrbit) {
                targetRotation.y += params.autoOrbitSpeed * 60;
                targetRotation.x = Math.sin(time * 0.1) * 0.3;
            }

            // Smooth rotation
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

            dnaGroup.rotation.x = currentRotation.x;
            dnaGroup.rotation.y = currentRotation.y + time * 0.01;

            // Pulsating glow animation on DNA spheres
            dnaGlowSpheres.forEach(sphere => {
                const pulse = Math.sin(time + sphere.userData.phaseOffset) * 0.3 + 0.7;
                sphere.material.emissiveIntensity = sphere.userData.baseEmissive * pulse;
            });

            // Animate particles with trails effect
            particles.forEach((particle, index) => {
                // Movement
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                particle.position.z += particle.userData.velocity.z;

                // Pulsating opacity
                const pulse = Math.sin(time * 2 + particle.userData.phaseOffset) * 0.3 + 0.5;
                particle.material.opacity = particle.userData.originalOpacity * pulse;

                // Slight size variation
                const scale = 1 + Math.sin(time * 3 + particle.userData.phaseOffset) * 0.2;
                particle.scale.setScalar(scale);

                // Reset particle if too far
                const distance = Math.sqrt(
                    particle.position.x ** 2 +
                    particle.position.y ** 2 +
                    particle.position.z ** 2
                );
                if (distance > 20) {
                    particle.position.set(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 8
                    );
                }
            });

            // Animate star field with parallax
            stars.forEach(starField => {
                starField.rotation.y = time * 0.0001;
                starField.rotation.x = time * 0.00005;
            });

            // Render with bloom effect
            composer.render();
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
