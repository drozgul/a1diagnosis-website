<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Helix Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a1520;
            font-family: Arial, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00d4ff;
            font-size: 14px;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00d4ff;
            font-size: 24px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="loading">Loading DNA Helix...</div>
        <div id="info">DNA Double Helix Visualization<br>Drag to rotate â€¢ Scroll to zoom</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        let scene, camera, renderer, dnaGroup;
        let particles = [];
        let mouse = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a1520, 10, 50);

            // Create camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 15;

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0a1520, 1);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create DNA group
            dnaGroup = new THREE.Group();
            scene.add(dnaGroup);

            // Create DNA helix
            createDNAHelix();

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x1a4a5a, 0.5);
            scene.add(ambientLight);

            // Add point lights
            const pointLight1 = new THREE.PointLight(0x00d4ff, 2, 100);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00d4ff, 2, 100);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            // Mouse controls
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('wheel', onMouseWheel, false);

            // Touch controls
            let touchStartX = 0;
            let touchStartY = 0;
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            document.addEventListener('touchmove', (e) => {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                targetRotation.y += deltaX * 0.005;
                targetRotation.x += deltaY * 0.005;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            // Window resize
            window.addEventListener('resize', onWindowResize, false);

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            // Start animation
            animate();
        }

        function createDNAHelix() {
            const height = 20;
            const radius = 3;
            const segments = 200;
            const turnCount = 4;

            // Materials
            const strandMaterial = new THREE.MeshPhongMaterial({
                color: 0x00d4ff,
                emissive: 0x00d4ff,
                emissiveIntensity: 0.5,
                shininess: 100,
                transparent: true,
                opacity: 0.8
            });

            const basePairMaterial = new THREE.MeshPhongMaterial({
                color: 0x00a8cc,
                emissive: 0x00a8cc,
                emissiveIntensity: 0.3,
                shininess: 50,
                transparent: true,
                opacity: 0.6
            });

            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00d4ff,
                transparent: true,
                opacity: 0.6
            });

            // Create helix strands
            for (let i = 0; i < segments; i++) {
                const t = (i / segments) * Math.PI * 2 * turnCount;
                const y = (i / segments) * height - height / 2;

                // Strand 1
                const x1 = Math.cos(t) * radius;
                const z1 = Math.sin(t) * radius;

                // Strand 2 (180 degrees offset)
                const x2 = Math.cos(t + Math.PI) * radius;
                const z2 = Math.sin(t + Math.PI) * radius;

                // Create spheres for strand 1
                const sphere1 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    strandMaterial
                );
                sphere1.position.set(x1, y, z1);
                dnaGroup.add(sphere1);

                // Create glow around sphere 1
                const glow1 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 16, 16),
                    glowMaterial
                );
                glow1.position.set(x1, y, z1);
                dnaGroup.add(glow1);

                // Create spheres for strand 2
                const sphere2 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    strandMaterial
                );
                sphere2.position.set(x2, y, z2);
                dnaGroup.add(sphere2);

                // Create glow around sphere 2
                const glow2 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 16, 16),
                    glowMaterial
                );
                glow2.position.set(x2, y, z2);
                dnaGroup.add(glow2);

                // Add connecting tubes
                if (i > 0) {
                    const prevT = ((i - 1) / segments) * Math.PI * 2 * turnCount;
                    const prevY = ((i - 1) / segments) * height - height / 2;

                    // Connection for strand 1
                    const prevX1 = Math.cos(prevT) * radius;
                    const prevZ1 = Math.sin(prevT) * radius;
                    const curve1 = new THREE.LineCurve3(
                        new THREE.Vector3(prevX1, prevY, prevZ1),
                        new THREE.Vector3(x1, y, z1)
                    );
                    const tubeGeometry1 = new THREE.TubeGeometry(curve1, 1, 0.08, 8, false);
                    const tube1 = new THREE.Mesh(tubeGeometry1, strandMaterial);
                    dnaGroup.add(tube1);

                    // Connection for strand 2
                    const prevX2 = Math.cos(prevT + Math.PI) * radius;
                    const prevZ2 = Math.sin(prevT + Math.PI) * radius;
                    const curve2 = new THREE.LineCurve3(
                        new THREE.Vector3(prevX2, prevY, prevZ2),
                        new THREE.Vector3(x2, y, z2)
                    );
                    const tubeGeometry2 = new THREE.TubeGeometry(curve2, 1, 0.08, 8, false);
                    const tube2 = new THREE.Mesh(tubeGeometry2, strandMaterial);
                    dnaGroup.add(tube2);
                }

                // Add base pairs (every 10 segments)
                if (i % 10 === 0) {
                    const basePairCurve = new THREE.LineCurve3(
                        new THREE.Vector3(x1, y, z1),
                        new THREE.Vector3(x2, y, z2)
                    );
                    const basePairGeometry = new THREE.TubeGeometry(basePairCurve, 1, 0.06, 8, false);
                    const basePair = new THREE.Mesh(basePairGeometry, basePairMaterial);
                    dnaGroup.add(basePair);
                }

                // Add particles for atmospheric effect
                if (i % 5 === 0) {
                    createParticle(x1, y, z1);
                    createParticle(x2, y, z2);
                }
            }
        }

        function createParticle(x, y, z) {
            const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x00d4ff,
                transparent: true,
                opacity: 0.4
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);

            // Random offset
            particle.position.set(
                x + (Math.random() - 0.5) * 2,
                y + (Math.random() - 0.5) * 2,
                z + (Math.random() - 0.5) * 2
            );

            particle.userData = {
                velocity: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                originalOpacity: 0.4
            };

            particles.push(particle);
            dnaGroup.add(particle);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            targetRotation.y = mouse.x * Math.PI;
            targetRotation.x = mouse.y * Math.PI * 0.5;
        }

        function onMouseWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(5, Math.min(30, camera.position.z));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Smooth rotation
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

            dnaGroup.rotation.x = currentRotation.x;
            dnaGroup.rotation.y = currentRotation.y + Date.now() * 0.0001;

            // Animate particles
            particles.forEach(particle => {
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                particle.position.z += particle.userData.velocity.z;

                // Fade in and out
                const opacity = particle.material.opacity;
                particle.material.opacity = opacity + (Math.random() - 0.5) * 0.02;
                particle.material.opacity = Math.max(0.1, Math.min(0.6, particle.material.opacity));

                // Reset particle if too far
                const distance = Math.sqrt(
                    particle.position.x ** 2 +
                    particle.position.y ** 2 +
                    particle.position.z ** 2
                );
                if (distance > 15) {
                    particle.position.set(
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 6
                    );
                }
            });

            renderer.render(scene, camera);
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
